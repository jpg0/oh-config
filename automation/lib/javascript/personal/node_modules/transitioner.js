const FileInputStream = Java.type("java.io.FileInputStream");
const File = Java.type("java.io.File");
const IOUtils = Java.type("org.apache.commons.io.IOUtils");

const { osgi, actions, items } = require('ohj');
const color = require('color');
let logger = require('ohj').log('transitioner');
let itemChannelLinkRegistry = osgi.getService('org.eclipse.smarthome.core.thing.link.ItemChannelLinkRegistry', 'org.openhab.core.thing.link.ItemChannelLinkRegistry');
let broker = actions.get("mqtt", "mqtt:broker:mosquitto");

class JSFileLoader {
    constructor(directoryName) {
        this.directoryName = directoryName;
    }

    getJS(name) {
        return this.loadFileAsString(`${this.directoryName}/${name}`);
    }

    loadFileAsString(fullpath) {
        let fisTargetFile = new FileInputStream(new File(fullpath));
        return IOUtils.toString(fisTargetFile, "UTF-8");
    }
}

let fileLoader = new JSFileLoader(Java.type("java.lang.System").getenv("OPENHAB_CONF") + '/transform');

function lookupChannelFromItemName(itemName) {
    let channel = itemChannelLinkRegistry.getBoundThings(itemName).iterator().next().getChannels().get(0);
    return {
        topic: channel.getConfiguration().get('commandTopic'),
        transformationPattern: channel.getConfiguration().get('transformationPatternOut').toString()
    }
}

function defaultTransformation(hsbString){
    let msg = {};

    let hsb = hsbString.split(',');

    msg.brightness = Math.round(hsb[2] / 100 * 254);
    let c = color.create(hsbString);
    msg.color = {
        hex: c.hex()
    }

    return msg;
}

function doTransform(hsbString, transformationFilename) {
    logger.debug("Using transform: " + transformationFilename);
    let transformJS = fileLoader.getJS(transformationFilename);
    let input = hsbString; //will be read in the eval
    let output = eval(transformJS);
    
    if(output) {
        return JSON.parse(output);
    } else {
        logger.warn(`Failed to execute transform (${transformationFilename}), falling back to default`);
        return defaultTransformation(hsbString);
    }
}

function buildColorMessage(hsbString, itemName, channelConf) {
    if(channelConf.transformationPattern.startsWith("JS:")) {
        return doTransform(hsbString, channelConf.transformationPattern.slice(3));
    } else {
        return defaultTransformation(hsb);
    }
}

function buildMessage(hsb_string_or_on_off, itemName, channelConf) {
    let msg = {};

    switch(hsb_string_or_on_off) {
        case 'ON':
        case 'OFF':
            msg.state = hsb_string_or_on_off;
            break;
        default:
            return buildColorMessage(hsb_string_or_on_off, itemName, channelConf);
    }

    return msg;
}

function transition(itemName, hsb_string_or_on_off, transitionTime){
        logger.debug(`Transitioning light ${itemName}`)

        //find the channel
        let channelConf;
        
        try {
            channelConf = lookupChannelFromItemName(itemName);
        } catch (e) {
            try {
                channelConf = lookupChannelFromItemName(itemName + "_Real");
            } catch(e) {
                logger.warn(`failed to transition ${itemName} due to ${e.message}, switching instead...`);
                items.getItem(itemName).sendCommand(hsb_string_or_on_off);
                return;
            }
        }


        let msg = buildMessage(hsb_string_or_on_off, itemName, channelConf);
        msg.transition = transitionTime;
        
        broker.publishMQTT(channelConf.topic,  JSON.stringify(msg));
        logger.debug(`Transitioned light ${itemName}`)
    }


module.exports = {
    transition
}