const color = require('color');
const log = require('ohj').log('colorlights');
const { LocalTime, ChronoUnit } = require('js-joda');
const { items } = require('ohj');

let todItem = items.getItem('vTimeOfDay');


//todo: extract
const EVENING_START_STR = "19:30";
const EVENING_START = LocalTime.parse(EVENING_START_STR);

let DAY_COLOUR_TEMP = 3200;
let NIGHT_COLOUR_TEMP = 200;

let adjustedColorTemp = (proportion) =>
{
    let adjustedProportion = 1 - (Math.pow(1 - proportion, 2));
    log.debug("temp="+((adjustedProportion * (DAY_COLOUR_TEMP - NIGHT_COLOUR_TEMP)) + NIGHT_COLOUR_TEMP));
    let rv = color.chroma.mix(
        color.chroma.temperature((adjustedProportion * (DAY_COLOUR_TEMP - NIGHT_COLOUR_TEMP)) + NIGHT_COLOUR_TEMP),
        "#ffe400",
        0.6 * adjustedProportion);

    return rv;
}

let COLOR_POLICY = {
    default: ctx => { 
        let c;
        switch (ctx.periodInDay) {
            case "NIGHT":
                c = adjustedColorTemp(0);
                if(ctx.item.tags.includes("NightDim")) {
                    c = c.darken().darken();
                }
                break;
            case "EVENING":
                let proportion = EVENING_START.until(ctx.now, ChronoUnit.MINUTES) / 60;
                
                proportion = Math.min(proportion, 1);
                proportion = Math.max(proportion, 0);

                c = adjustedColorTemp(1 - proportion);
                break;
            default:
                c = adjustedColorTemp(1);
                break;
        }

        log.debug("chosen color: " + c.hsv())

        return color.hsb(c);
    },
    pink: ctx => {
        //todo
    }
}

let targetColorForItem = function(item, time) {

    let policyName = item.getMetadataValue("color_policy");
    let policy = COLOR_POLICY[policyName] || COLOR_POLICY.default;

    return policy({
        periodInDay: todItem.state,
        now: time || LocalTime.now(),
        item: item,
    });
}

let determineColor = function (/*item*/ fromItem, time) {
    let toColor = targetColorForItem(fromItem, time);
    let fromColor = fromItem.state || "0,0,0";
    let to = color.create(toColor);
    let from = color.create(fromColor);
    log.debug(`merging color: ${from}->${to}`);

    return color.hsb(to.set('hsv.v', Math.min(to.get('hsv.v'), from.get('hsv.v'))));
}


module.exports = {
    targetColorForItem,
    determineColor
}

